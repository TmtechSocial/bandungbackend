const processContentComponent = require('./content');

/**
 * Enhanced helper function to get nested data using dot notation with unlimited depth support
 * @param {Object} obj - The object to traverse
 * @param {String} path - Dot notation path (e.g., "a.b.c.d.e.f.g")
 * @returns {*} The value at the specified path or null if not found
 */
function getNestedData(obj, path) {
    if (!path || !obj) return null;
    
    console.log(`[getNestedData] Searching for path: ${path} in:`, Object.keys(obj));
    
    const keys = path.split('.');
    let current = obj;
    let navigationHistory = [];
    
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        navigationHistory.push({
            step: i,
            key: key,
            currentType: typeof current,
            isArray: Array.isArray(current),
            availableKeys: current && typeof current === 'object' ? Object.keys(current) : []
        });
        
        console.log(`[getNestedData] Step ${i}: Looking for key "${key}" in:`, 
            typeof current, 
            Array.isArray(current) ? `Array(${current.length})` : Object.keys(current || {}));
        
        if (current && typeof current === 'object') {
            if (key in current) {
                current = current[key];
                console.log(`[getNestedData] Step ${i}: Found "${key}", type:`, 
                    typeof current, 
                    Array.isArray(current) ? `Array(${current.length})` : '');
                
                // Enhanced array navigation for unlimited depth
                if (Array.isArray(current) && i < keys.length - 1) {
                    if (current.length > 0) {
                        console.log(`[getNestedData] Step ${i}: Entering first element of array for further navigation (${keys.length - i - 1} steps remaining)`);
                        current = current[0];
                        
                        // Validate that we can continue navigation
                        if (!current || typeof current !== 'object') {
                            console.log(`[getNestedData] Step ${i}: Array element is not navigable:`, typeof current);
                            console.log(`[getNestedData] Navigation history:`, navigationHistory);
                            return null;
                        }
                    } else {
                        console.log(`[getNestedData] Step ${i}: Array is empty, cannot navigate further`);
                        console.log(`[getNestedData] Navigation history:`, navigationHistory);
                        return null;
                    }
                }
            } else {
                console.log(`[getNestedData] Step ${i}: Key "${key}" not found`);
                console.log(`[getNestedData] Available keys at step ${i}:`, Object.keys(current));
                console.log(`[getNestedData] Navigation history:`, navigationHistory);
                return null;
            }
        } else {
            console.log(`[getNestedData] Step ${i}: Current is not an object:`, current);
            console.log(`[getNestedData] Navigation history:`, navigationHistory);
            return null;
        }
    }
    
    console.log(`[getNestedData] SUCCESS - Final result for path ${path}:`, 
        typeof current, 
        Array.isArray(current) ? `Array(${current.length})` : 'Object');
    console.log(`[getNestedData] Total navigation steps: ${keys.length}`);
    return current;
}

/**
 * Helper function to get the last part of a nested path
 * @param {String} tablePath - Dot notation path (e.g., "mo_retur_receive.invoice_retur_to_invoice")
 * @returns {String} The last part of the path
 */
function getTableName(tablePath) {
    if (!tablePath) return tablePath;
    const parts = tablePath.split('.');
    return parts[parts.length - 1];
}



function processDataGridComponent(component, queryData, formState) {
    const { components } = component;
    const newDefaultValue = [];

    // Validasi data API/GraphQL
    if (formState && formState.apiResults) {
        console.log("[datagrid] API Results available keys:", Object.keys(formState.apiResults));
    } else {
        console.warn("[datagrid] API Results belum tersedia!");
    }

    // Proses content component terlebih dahulu, simpan hasil HTML berdasarkan key
    const contentHTMLMap = {};
    components.forEach((subComponent) => {
        if (subComponent.type === 'content') {
            // console.log(`Processing content component inside DataGrid: ${subComponent.key}`);
            processContentComponent(subComponent, queryData, formState);
            if (subComponent.html) {
                contentHTMLMap[subComponent.key] = subComponent.html;
            }
        }
    });

    // Identifikasi komponen utama (yang memiliki table dan bukan apiSource saja)
    const mainComponents = components.filter(sc => 
        sc.table && 
        sc.type !== 'content' && 
        !sc.apiSource && 
        ['textfield', 'textarea', 'number'].includes(sc.type)
    );

    //console.log("Main components (table-based, non-API):", mainComponents.map(c => c.key));

    // Buat mapping komponen berdasarkan nama table (supporting unlimited nested paths)
    const tableComponentMap = {};
    const primaryTablePath = {}; // Track primary path for nested grouping
    
    // STEP 1: Analyze all table paths to find optimal grouping strategy
    const allTablePaths = components
        .filter(sc => sc.type !== 'content' && sc.table)
        .map(sc => sc.table);
    
    console.log(`[datagrid] All table paths found:`, allTablePaths);
    
    // STEP 2: Find the longest common prefix for grouping
    function findLongestCommonPrefix(paths) {
        if (paths.length === 0) return {};
        if (paths.length === 1) return { [paths[0]]: paths[0] };
        
        const groupings = {};
        const processed = new Set();
        
        paths.forEach(path => {
            if (processed.has(path)) return;
            
            // Find all paths that share a common prefix with this path
            const relatedPaths = paths.filter(otherPath => {
                if (otherPath === path) return true;
                
                // Check if one path is a prefix of another
                return path.startsWith(otherPath + '.') || otherPath.startsWith(path + '.');
            });
            
            if (relatedPaths.length > 1) {
                // Find the actual common prefix
                const parts = relatedPaths.map(p => p.split('.'));
                let commonLength = Math.min(...parts.map(p => p.length));
                
                // Find the maximum common prefix length
                for (let i = 0; i < commonLength; i++) {
                    const firstPart = parts[0][i];
                    const allMatch = parts.every(p => p[i] === firstPart);
                    if (!allMatch) {
                        commonLength = i;
                        break;
                    }
                }
                
                // Use at least 2 levels if available, but can be more for complex nesting
                const primaryPath = parts[0].slice(0, Math.max(2, commonLength)).join('.');
                
                relatedPaths.forEach(relatedPath => {
                    groupings[relatedPath] = primaryPath;
                    processed.add(relatedPath);
                });
                
                console.log(`[datagrid] Grouped paths under "${primaryPath}":`, relatedPaths);
            } else {
                // Single path, use itself as primary
                groupings[path] = path;
                processed.add(path);
                console.log(`[datagrid] Single path "${path}" uses itself as primary`);
            }
        });
        
        return groupings;
    }
    
    const pathGroupings = findLongestCommonPrefix(allTablePaths);
    
    components.forEach((subComponent) => {
        if (subComponent.type === 'content') return; // Sudah diproses
        const table = subComponent.table;
        if (!table) return;
        
        // Use the calculated primary path
        const primaryPath = pathGroupings[table] || table;
        
        // Group components by primary path, not exact table path
        if (!tableComponentMap[primaryPath]) {
            tableComponentMap[primaryPath] = [];
            primaryTablePath[primaryPath] = new Set();
        }
        tableComponentMap[primaryPath].push(subComponent);
        primaryTablePath[primaryPath].add(table); // Track all table paths under this primary
    });
    
    console.log(`[datagrid] Final primary path groupings:`, Object.fromEntries(
        Object.entries(tableComponentMap).map(([primary, components]) => [
            primary, 
            Array.from(primaryTablePath[primary])
        ])
    ));

    // SPECIAL CASE: Jika tidak ada table components tetapi ada API components,
    // kita perlu membuat rows berdasarkan API data
    const hasTableComponents = Object.keys(tableComponentMap).length > 0;
    const hasApiComponents = components.some(sc => sc.apiSource && sc.type !== 'content');

    console.log('[datagrid] Table component mapping:', Object.keys(tableComponentMap));
    console.log(`[datagrid] hasTableComponents: ${hasTableComponents}, hasApiComponents: ${hasApiComponents}`);
    
    // Debug: Log complete data structure
    if (queryData && queryData.length > 0) {
        queryData.forEach((queryItem, qIndex) => {
            if (queryItem.graph) {
                console.log(`[datagrid] Query ${qIndex} graph structure:`, JSON.stringify(queryItem.graph, null, 2));
            }
        });
    }

    // SPECIAL HANDLING: Jika tidak ada table components, gunakan API data untuk membuat rows
    if (!hasTableComponents && hasApiComponents && formState?.apiResults) {
        console.log(`[datagrid] ðŸ”„ SPECIAL CASE: No table components, creating rows from API data`);
        
        // Cari API source yang memiliki array data untuk dijadikan basis rows
        const apiSources = components
            .filter(sc => sc.apiSource && sc.type !== 'content')
            .map(sc => sc.apiSource.source);
        
        const uniqueApiSources = [...new Set(apiSources)];
        console.log(`[datagrid] Available API sources:`, uniqueApiSources);
        
        // Prioritaskan API yang memiliki data array
        let primaryApiSource = null;
        let primaryApiData = null;
        
        // Prioritas khusus: coba 'bom', 'partComponents', atau array terbesar
        const priorityOrder = ['bom', 'partComponents', 'parts'];
        
        for (const source of priorityOrder) {
            if (uniqueApiSources.includes(source)) {
                const apiData = formState.apiResults[source];
                if (Array.isArray(apiData) && apiData.length > 0) {
                    primaryApiSource = source;
                    primaryApiData = apiData;
                    console.log(`[datagrid] âœ… Using priority API source: ${source} with ${apiData.length} items`);
                    break;
                }
            }
        }
        
        // Fallback: gunakan array pertama yang ditemukan
        if (!primaryApiSource) {
            for (const source of uniqueApiSources) {
                const apiData = formState.apiResults[source];
                if (Array.isArray(apiData) && apiData.length > 0) {
                    primaryApiSource = source;
                    primaryApiData = apiData;
                    console.log(`[datagrid] âœ… Using fallback API source: ${source} with ${apiData.length} items`);
                    break;
                }
            }
        }
        
        if (primaryApiSource && primaryApiData) {
            // Buat rows berdasarkan primary API data
            primaryApiData.forEach((apiItem, index) => {
                const row = {};
                
                // STEP 1: Inisialisasi semua component keys
                components.forEach((sc) => {
                    if (sc.type === 'content') {
                        // Content sudah diproses di contentHTMLMap
                        return;
                    }
                    
                    if (sc.key === "image") {
                        row[sc.key] = "unknown"; // Default untuk image
                    } else {
                        row[sc.key] = undefined; // Default untuk field lain
                    }
                });
                
                // STEP 2: Isi data dari primary API
                Object.keys(apiItem).forEach(key => {
                    row[key] = apiItem[key];
                });
                
                // STEP 3: Tambahkan content HTML
                Object.entries(contentHTMLMap).forEach(([key, html]) => {
                    row[key] = html;
                });
                
                console.log(`[datagrid] API Row ${index}: Created from ${primaryApiSource}, fields:`, Object.keys(row).filter(k => k !== 'image_preview'));
                newDefaultValue.push(row);
            });
        }
    }

    // Proses data dari query (SQL/Graph) - FIXED for nested support  
    if (queryData && hasTableComponents) {
        console.log("[datagrid] Query data structure:", queryData.map(item => ({
            type: item.sqlQuery ? 'SQL' : 'Graph',
            table: item.sqlQuery?.table || Object.keys(item.graph || {}),
            hasGraph: !!item.graph,
            graphKeys: item.graph ? Object.keys(item.graph) : []
        })));

        queryData.forEach((queryItem) => {
            Object.entries(tableComponentMap).forEach(([primaryPath, tableComponents]) => {
                console.log(`[datagrid] Processing primary path: ${primaryPath}`);
                console.log(`[datagrid] Related table paths:`, Array.from(primaryTablePath[primaryPath]));

                // Handle SQL data (direct table match only for SQL)
                if (queryItem.sqlQuery?.table === primaryPath) {
                    console.log(`[datagrid] Processing SQL data for table: ${primaryPath}, rows: ${queryItem.sqlQuery.data.length}`);
                    queryItem.sqlQuery.data.forEach((item, index) => {
                        const row = {};
                        
                        // STEP 1: Simpan SEMUA field dari query data (dinamis)
                        Object.keys(item).forEach(key => {
                            row[key] = item[key];
                        });
                        
                        // STEP 2: Override dengan component-specific logic
                        components.forEach((sc) => {
                            if (sc.key === "image") {
                                row[sc.key] = "unknown";
                            } else if (row[sc.key] === undefined) {
                                row[sc.key] = undefined;
                            }
                        });
                        
                        // STEP 3: Tambahkan content HTML yang sudah diproses
                        Object.entries(contentHTMLMap).forEach(([key, html]) => {
                            row[key] = html;
                        });
                        
                        console.log(`[datagrid] SQL Row ${index}: ${item.product_name?.substring(0, 40)}..., fields saved:`, Object.keys(row).filter(k => k !== 'image_preview'));
                        newDefaultValue.push(row);
                    });
                }

                // Handle Graph data - ENHANCED nested path processing
                if (queryItem.graph) {
                    let processedData = false;
                    let primaryData = null;
                    
                    // STEP 1: Get primary data from the main nested path
                    if (primaryPath.includes('.')) {
                        primaryData = getNestedData(queryItem.graph, primaryPath);
                        if (primaryData && Array.isArray(primaryData)) {
                            console.log(`[datagrid] âœ… FOUND primary nested graph data for path: ${primaryPath}, rows: ${primaryData.length}`);
                            processedData = true;
                            
                            primaryData.forEach((primaryItem, index) => {
                                const row = {};
                                
                                // STEP 1A: Simpan SEMUA field dari primary data
                                Object.keys(primaryItem).forEach(key => {
                                    row[key] = primaryItem[key];
                                });
                                
                                // STEP 1B: Process each component and get data from appropriate nested path
                                tableComponents.forEach((sc) => {
                                    if (sc.type === 'content' || !sc.table) return;
                                    
                                    const componentTablePath = sc.table;
                                    
                                    // If component has same path as primary, data already loaded
                                    if (componentTablePath === primaryPath) {
                                        // Data already loaded in step 1A
                                        if (sc.key === "image" && row[sc.key] === undefined) {
                                            row[sc.key] = "unknown";
                                        }
                                        return;
                                    }
                                    
                                    // If component has deeper nested path, get data from that path
                                    if (componentTablePath.startsWith(primaryPath + '.')) {
                                        const extraPath = componentTablePath.substring(primaryPath.length + 1);
                                        console.log(`[datagrid] Processing deeper nested path: ${extraPath} for component ${sc.key}`);
                                        
                                        // Navigate from current primary item to deeper nested data
                                        const deeperData = getNestedData(primaryItem, extraPath);
                                        
                                        if (deeperData) {
                                            if (Array.isArray(deeperData) && deeperData.length > 0) {
                                                // Take first item from array
                                                const deeperItem = deeperData[0];
                                                if (deeperItem && typeof deeperItem === 'object') {
                                                    // Merge deeper data into row, prioritizing specific component key
                                                    if (sc.key in deeperItem) {
                                                        row[sc.key] = deeperItem[sc.key];
                                                    } else {
                                                        // If specific key not found, merge all fields
                                                        Object.keys(deeperItem).forEach(key => {
                                                            if (row[key] === undefined) {
                                                                row[key] = deeperItem[key];
                                                            }
                                                        });
                                                    }
                                                }
                                            } else if (typeof deeperData === 'object') {
                                                // Single object
                                                if (sc.key in deeperData) {
                                                    row[sc.key] = deeperData[sc.key];
                                                } else {
                                                    // Merge all fields from deeper object
                                                    Object.keys(deeperData).forEach(key => {
                                                        if (row[key] === undefined) {
                                                            row[key] = deeperData[key];
                                                        }
                                                    });
                                                }
                                            }
                                        }
                                        
                                        // Ensure image field has default value
                                        if (sc.key === "image" && row[sc.key] === undefined) {
                                            row[sc.key] = "unknown";
                                        }
                                    }
                                });
                                
                                // STEP 1C: Override dengan component-specific logic
                                components.forEach((sc) => {
                                    if (sc.key === "image" && row[sc.key] === undefined) {
                                        row[sc.key] = "unknown";
                                    }
                                });
                                
                                // STEP 1D: Tambahkan content HTML yang sudah diproses
                                Object.entries(contentHTMLMap).forEach(([key, html]) => {
                                    row[key] = html;
                                });
                                
                                console.log(`[datagrid] Enhanced Nested Row ${index}: fields saved:`, Object.keys(row).filter(k => k !== 'image_preview'));
                                newDefaultValue.push(row);
                            });
                        } else if (primaryData && typeof primaryData === 'object') {
                            console.log(`[datagrid] âœ… FOUND primary nested graph object for path: ${primaryPath}`);
                            processedData = true;
                            
                            const row = {};
                            
                            // Process single object with enhanced nested handling
                            Object.keys(primaryData).forEach(key => {
                                row[key] = primaryData[key];
                            });
                            
                            // Process deeper nested paths for components
                            tableComponents.forEach((sc) => {
                                if (sc.type === 'content' || !sc.table) return;
                                
                                const componentTablePath = sc.table;
                                if (componentTablePath !== primaryPath && componentTablePath.startsWith(primaryPath + '.')) {
                                    const extraPath = componentTablePath.substring(primaryPath.length + 1);
                                    const deeperData = getNestedData(primaryData, extraPath);
                                    
                                    if (deeperData && typeof deeperData === 'object') {
                                        if (sc.key in deeperData) {
                                            row[sc.key] = deeperData[sc.key];
                                        }
                                    }
                                }
                                
                                if (sc.key === "image" && row[sc.key] === undefined) {
                                    row[sc.key] = "unknown";
                                }
                            });
                            
                            // Add content HTML
                            Object.entries(contentHTMLMap).forEach(([key, html]) => {
                                row[key] = html;
                            });
                            
                            console.log(`[datagrid] Enhanced Nested Object: fields saved:`, Object.keys(row).filter(k => k !== 'image_preview'));
                            newDefaultValue.push(row);
                        }
                    }
                    
                    // FALLBACK: Try direct table match only if nested path didn't work
                    if (!processedData && queryItem.graph[primaryPath]) {
                        console.log(`[datagrid] ðŸ“Œ Using direct graph data for table: ${primaryPath}, rows: ${queryItem.graph[primaryPath].length}`);
                        queryItem.graph[primaryPath].forEach((item, index) => {
                            const row = {};
                            
                            // STEP 1: Simpan SEMUA field dari query data (dinamis)
                            Object.keys(item).forEach(key => {
                                row[key] = item[key];
                            });
                            
                            // STEP 2: Override dengan component-specific logic
                            components.forEach((sc) => {
                                if (sc.key === "image") {
                                    row[sc.key] = "unknown";
                                } else if (row[sc.key] === undefined) {
                                    row[sc.key] = undefined;
                                }
                            });
                            
                            // STEP 3: Tambahkan content HTML yang sudah diproses
                            Object.entries(contentHTMLMap).forEach(([key, html]) => {
                                row[key] = html;
                            });
                            
                            console.log(`[datagrid] Direct Graph Row ${index}: ${item.product_name?.substring(0, 40)}..., fields saved:`, Object.keys(row).filter(k => k !== 'image_preview'));
                            newDefaultValue.push(row);
                        });
                    }
                    
                    // Log if no data found
                    if (!processedData && !queryItem.graph[primaryPath]) {
                        console.log(`[datagrid] âŒ No data found for primary path: ${primaryPath}`);
                        console.log(`[datagrid] Available graph keys:`, Object.keys(queryItem.graph));
                        
                        // Debug: Show the actual nested structure
                        const debugNestedData = getNestedData(queryItem.graph, primaryPath);
                        console.log(`[datagrid] Debug nested data for ${primaryPath}:`, debugNestedData);
                    }
                }
            });
        });
    }

    // Proses data dari API hanya jika diperlukan untuk melengkapi data
    const apiComponentMap = {};
    components.forEach((sc) => {
        if (sc.type === 'content' || !sc.apiSource) return;
        const source = sc.apiSource.source;
        if (!apiComponentMap[source]) {
            apiComponentMap[source] = [];
        }
        apiComponentMap[source].push(sc);
    });

    // Proses data dari API hanya untuk update field image (dan field lain yang diperlukan)
    if (Object.keys(apiComponentMap).length > 0 && newDefaultValue.length > 0) {
        console.log(`[datagrid] Query rows: ${newDefaultValue.length}, API data available: ${Object.keys(formState.apiResults || {}).length}`);
        
        Object.entries(apiComponentMap).forEach(([source, apiComponents]) => {
            const apiItems1 = formState.apiResults?.[source];
            const apiItems = Array.isArray(apiItems1) ? apiItems1 : [apiItems1];
            console.log(`[datagrid] Processing API source [${source}]:`, Array.isArray(apiItems1) ? `Array(${apiItems1.length})` : typeof apiItems1);
            const dataPath = apiComponents[0]?.apiSource?.dataPath || [];
            console.log(`[datagrid] API dataPath for ${source}:`, dataPath);
            let items = apiItems;
            
            // Traverse dataPath untuk mendapatkan array data yang benar
            for (const path of dataPath) {
                items = items?.[path] ?? null;
            }

            // Validasi apakah data API valid (array dengan elemen)
            const isValidApiData = items && Array.isArray(items) && items.length > 0;
            console.log(`[datagrid] API source [${source}]: ${isValidApiData ? `Array(${items.length})` : 'Invalid/Empty'}`);
            
            if (isValidApiData) {
                console.log(`[datagrid] Mapping ${newDefaultValue.length} rows with ${items.length} API items from source: ${source}`);
                
                // Buat mapping berdasarkan berbagai field yang mungkin
                const apiItemsByValue = {};
                const apiItemsByRowIndex = {};
                
                items.forEach((apiItem, apiIndex) => {
                    // Primary mapping by pk
                    if (apiItem && apiItem.pk) {
                        apiItemsByValue[apiItem.pk] = apiItem;
                    }
                    
                    // Secondary mapping by sub_part for BOM data
                    if (apiItem && apiItem.sub_part) {
                        apiItemsByValue[apiItem.sub_part] = apiItem;
                    }
                    
                    // Tertiary mapping by datagrid row index (untuk datagrid APIs)
                    if (apiItem && apiItem._datagridRowIndex !== undefined) {
                        apiItemsByRowIndex[apiItem._datagridRowIndex] = apiItem;
                    }
                    
                    // Quaternary mapping by array index sebagai fallback
                    if (!apiItemsByRowIndex[apiIndex]) {
                        apiItemsByRowIndex[apiIndex] = apiItem;
                    }
                });
                
                console.log(`[datagrid] API mapping created for ${source}:`, {
                    byValue: Object.keys(apiItemsByValue).length,
                    byRowIndex: Object.keys(apiItemsByRowIndex).length,
                    totalApiItems: items.length
                });
                
                // Update row dengan data API yang cocok
                newDefaultValue.forEach((row, rowIndex) => {
                    let apiItem = null;
                    let matchMethod = '';
                    
                    // Strategy 1: Match by pk field
                    if (!apiItem && row.pk && apiItemsByValue[row.pk]) {
                        apiItem = apiItemsByValue[row.pk];
                        matchMethod = `pk=${row.pk}`;
                    }
                    
                    // Strategy 2: Match by sub_part_id (untuk BOM matching)
                    if (!apiItem && row.sub_part_id && apiItemsByValue[row.sub_part_id]) {
                        apiItem = apiItemsByValue[row.sub_part_id];
                        matchMethod = `sub_part_id=${row.sub_part_id}`;
                    }
                    
                    // Strategy 3: Enhanced dynamic matching by all row fields
                    if (!apiItem) {
                        for (const key of Object.keys(row)) {
                            if (key === 'image' || key === 'image_preview') continue;
                            const rowValue = row[key];
                            if (rowValue === undefined || rowValue === null) continue;
                            if (typeof rowValue !== 'string' && typeof rowValue !== 'number') continue;
                            if (apiItemsByValue[rowValue]) {
                                apiItem = apiItemsByValue[rowValue];
                                matchMethod = `dynamicKey=${key}=${rowValue}`;
                                break;
                            }
                        }
                    }
                    
                    // Strategy 4: Enhanced BOM matching - find by sub_part matching row.pk
                    if (!apiItem && source === 'bom' && row.pk) {
                        const bomItem = items.find(item => item.sub_part == row.pk);
                        if (bomItem) {
                            apiItem = bomItem;
                            matchMethod = `bom.sub_part=${bomItem.sub_part}->row.pk=${row.pk}`;
                        }
                    }
                    
                    // Strategy 5: partComponents direct pk matching
                    if (!apiItem && source === 'partComponents' && row.pk) {
                        const componentItem = items.find(item => item.pk == row.pk);
                        if (componentItem) {
                            apiItem = componentItem;
                            matchMethod = `partComponents.pk=${componentItem.pk}->row.pk=${row.pk}`;
                        }
                    }
                    
                    // Strategy 6: Row index fallback
                    if (!apiItem && apiItemsByRowIndex[rowIndex] !== undefined) {
                        apiItem = apiItemsByRowIndex[rowIndex];
                        matchMethod = `rowIndex=${rowIndex}`;
                    }
                
                    console.log(`[datagrid] Row ${rowIndex}: Product="${row.product_name?.substring(0, 30) || row.full_name?.substring(0, 30) || 'Unknown'}...", Match: ${matchMethod || 'NONE'}, API found: ${!!apiItem}`);
                    
                    // Apply API data to row based on component mappings
                    apiComponents.forEach((sc) => {
                        const valKey = sc.apiSource.valueKey || sc.key;
                        const apiValue = apiItem?.[valKey];
                        
                        if (sc.key === "image") {
                            // Replace "unknown" hanya jika ada data API yang valid dan tidak kosong
                            if (apiValue !== undefined && apiValue !== null && apiValue !== "") {
                                console.log(`[datagrid] Row ${rowIndex}: Image updated from "${row[sc.key]}" to "${apiValue}" via ${matchMethod}`);
                                row[sc.key] = apiValue;
                            } else {
                                console.log(`[datagrid] Row ${rowIndex}: Image remains "${row[sc.key]}" (${matchMethod}, API value: ${apiValue})`);
                            }
                        } else {
                            // Untuk field lain, update jika ada data valid
                            if (apiValue !== undefined && apiValue !== null) {
                                console.log(`[datagrid] Row ${rowIndex}: Field ${sc.key} updated to "${apiValue}" via ${matchMethod}`);
                                row[sc.key] = apiValue;
                            }
                        }
                    });
                });
            }
            // Jika API kosong/null/undefined/array kosong, semua image tetap "unknown"
        });
    }

    // Jika tidak ada data dari query, gunakan defaultValue yang sudah ada
    if (newDefaultValue.length === 0 && component.defaultValue && Array.isArray(component.defaultValue)) {
        // console.log("Using existing defaultValue");
        
        component.defaultValue.forEach((row) => {
            const processedRow = {};
            components.forEach((sc) => {
                if (sc.key === "image") {
                    // Untuk field image, set "unknown" jika kosong/null/undefined
                    processedRow[sc.key] = (row[sc.key] && row[sc.key] !== "" && row[sc.key] !== null) ? row[sc.key] : "unknown";
                } else {
                    // Untuk field lain, ambil nilai asli
                    processedRow[sc.key] = row[sc.key];
                }
            });
            // Tambahkan content HTML
            Object.entries(contentHTMLMap).forEach(([key, html]) => {
                processedRow[key] = html;
            });
            newDefaultValue.push(processedRow);
        });
    }

    // Jika masih tidak ada data sama sekali, buat baris kosong
    if (newDefaultValue.length === 0) {
        const emptyRow = {};
        components.forEach((sc) => {
            if (sc.key === "image") {
                // Field image selalu "unknown" jika tidak ada data
                emptyRow[sc.key] = "unknown";
            } else {
                // Field lain undefined
                emptyRow[sc.key] = undefined;
            }
        });
        // Tambahkan content HTML
        Object.entries(contentHTMLMap).forEach(([key, html]) => {
            emptyRow[key] = html;
        });
        newDefaultValue.push(emptyRow);
    }

    // Final validation: pastikan setiap row memiliki field image dengan value yang tepat
    newDefaultValue.forEach((row, rowIndex) => {
        components.forEach(sc => {
            if (sc.key === "image") {
                // Jika field image masih kosong/null/undefined, isi dengan "unknown"
                if (!row[sc.key] || row[sc.key] === null || row[sc.key] === undefined || row[sc.key] === "") {
                    row[sc.key] = "unknown";
                }
            }
        });
    });

    component.defaultValue = newDefaultValue;
    
    // Debug logging untuk melihat hasil akhir
    const imageFields = newDefaultValue.map((row, index) => ({
        rowIndex: index,
        image: row.image,
        hasValidImage: row.image && row.image !== "unknown" && row.image !== ""
    }));
    
    console.log(`[datagrid] Final result: ${newDefaultValue.length} rows processed`);
    console.log(`[datagrid] Image field status:`, imageFields);
    
    //console.log("Final default value for DataGrid component:", component.defaultValue);
    //console.log("Number of rows:", newDefaultValue.length);
}

module.exports = processDataGridComponent;
